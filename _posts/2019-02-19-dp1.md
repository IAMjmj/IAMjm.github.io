---

layout: post
title: ''包子凑数
subtitle: '完全背包'
date: 2019-02-19
categories: 技术
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags: acm

---



## 题目描述

小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。

每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。

当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。

小明想知道一共有多少种数目是包子大叔凑不出来的。

输入
----
第一行包含一个整数N。(1 <= N <= 100)
以下N行每行包含一个整数Ai。(1 <= Ai <= 100)  

输出
----
一个整数代表答案。如果凑不出的数目有无限多个，输出INF。

例如，
输入：
2  
4  
5   

程序应该输出：
6  

再例如，
输入：
2  
4  
6    

程序应该输出：
INF

样例解释：
对于样例1，凑不出的数目包括：1, 2, 3, 6, 7, 11。  

对于样例２，所有奇数都凑不出来，所以有无限多个

## 分析

第一首先我们先看数据范围，n最大为100，每笼包子最多有100

个，就说明他叫我们判断的数据不会超过10000 所以我们只用判断10000

以内有多少种不可以被凑出来就行


  

第二，我们分析，对于样例 2，4，5

   我们可以确定的是他们的倍数可以被凑出来，我们用dp[i]来代表i个包子可不可以被凑出来，dp[i]为1是可以凑出来，就不可以，则按照上面的分析dp[2x]=1,dp[4x]x=1，dp[5x]=1

   同样，我们也可以确定的是，2x+5或4 4x+5或2等，也是可以被凑出来的

对于这个我们怎么来表示呢？

   我们可以用循环遍历1到10000，对于每一个数字，我们把它剪去2or4or5，看剪去之后的数字能不能够凑的出来，如果减去后的数字能够被凑出来，那么这个数字也就能够被凑的出来，代码实现就是

```c++
dp[0]=1;
for(i=1;i<=n;i++)
    for(j=1;j<10000;j++)
      {
          if(a[i]>j)continue;
          if(dp[j-a[i]]==1)dp[j]=1;       
      }
```

这样我们就能判断出10000以内有多少种不能够被凑出来了，

对于inf的问题网上的说是如果n个数的最大公约数不为1那么凑不出的数字就有无限种

其实就可以按照样例二来理解，他们都是偶数，那么gcd肯定不为1 然后他们对于所有奇数都凑不出来。

也可以这样理解，对于2 4 6这组数据，我们可以设为2x 4x 6x

他们的gcd为2，实际上我们发现他们可以合并成2x，就凑不出来所有的奇数

同理2x 4x 5x就可以看成2x 5x，他们的gcd就为1,此时把他们看成两个一元函数，这里可以发现2x+5,2x+7,2x+13...都可以凑出来，再在坐标上画一下，就可以发现，他们不可以凑出来的数字是有限的。

可以看出，如果n个数的gcd不为1，那么就相当与只有一笼包子在凑数，这种情况就会出现INF

## 具体代码

```c++
#include <bits/stdc++.h>
using namespace std;
#define r(x) x=read(x)
bool dp[100005];
int a[105];
inline int read()
{
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    returnn x*f;
}
int main()
{
    int n,i,j,k,gcd,ans=0;
    r(n);
    r(a[0]);
    gcd=a[0];
    for(i=1;i<n;i++){
        r(a[i]);
        gcd=__gcd(a[i],gcd);
    }
    if(gcd!=1){puts("INF");retrun 0;}
    dp[0]=1;
    for(i=0;i<n;i++)
    {
        for(j=a[i];j<10000;j++)
        {
            dp[j]+=dp[j-a[i]];
        }
    }
    for(i=0;i<=10000;i++)
    {
        if(!dp[i])ans++;
    }
    cout<<ans<<endl;                    
    return 0;
}
```

